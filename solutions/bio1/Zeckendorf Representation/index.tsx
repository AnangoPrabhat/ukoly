import { SCodeBlock, SText, STitle } from "components";
import { brace } from "solutions/util";

export const ZeckendorfRepresentation = () => {
  return (
    <>
      <STitle>Idea</STitle>
      <SText>
      An invalid Zeckendorf representation can be made into a valid one by repeatedly adding any two numbers that are at position $i$ and $i + 1$ in the Fibonacci sequence to get the number at position $i + 2$.      
      </SText>

      <STitle>Solution</STitle>
      <SText>
        A valid Zeckendorf representation can be generated by getting the largest Fibonacci number lower than or equal to the input integer $n$, subtracting that number from $n$ and repeating while $n$ is positive.
      </SText>
      <SText>
        This method can be proven to always produce a valid representation by contradiction.
        Assume that this method produced two numbers $a_{brace("i")}$ and $a_{brace("i - 1")}$ in the representation, where $a_{brace("j")}$ is the number at position $j$ in the Fibonacci sequence.
        Therefore, $a_{brace("i")} \leq n$ and $a_{brace("i - 1")} \leq n - a_i$. Therefore, $a_{brace("i - 1")} + a_i \leq n$ and so $a_{brace("i + 1")} \leq n$. But then the method would have included $a_{brace("i + 1")}$ instead of $a_i$ and $a_{brace("i - 1")}$ in the representation. Therefore, the solution produced cannot be invalid.
      </SText>
      <STitle>Code</STitle>
      <SCodeBlock path="zeckendorfrepresentation/sol" />
    </>
  );
};
